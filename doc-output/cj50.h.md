<!-- THIS FILE WAS AUTO-GENERATED by gendoc. DO NOT EDIT! -->

This is the main header file of the cj50 library collection.

It includes the various other files (see the [documentation
index](index.md)), and additionally provides the utilities
described below. Besides additional functions and macros, it
defines a number of generic functions that dispatch to functions
from various other files.

# Normal functions

## get_CStr {#one_get_CStr}

```C
Option(CStr) get_CStr()
```

Read a CStr from stdin (standard input), terminated by a newline
(the newline is not included in the returned string). Returns none
on end of file (when ctl-d is pressed).

## get_String {#one_get_String}

```C
Option(String) get_String()
```

Read a String from standard input, terminated by a
newline. Returns none on end of file (when ctl-d is pressed).

Note: currently can't take a `'\0'` as it works via `get_CStr`.

## parse_int {#one_parse_int}

```C
Result(int, ParseError) parse_int(cstr s)
```

Translate a string into an `int` if possible.

## get_int {#one_get_int}

```C
Option(int) get_int()
```

Read an integer number from standard input, terminated by a
newline. Returns none on end of file (when ctl-d is pressed).

## parse_nat {#one_parse_nat}

```C
Result(int, ParseError) parse_nat(cstr s)
```

Translate a string into an `int` in the natural number range (1 or
higher) if possible.

## get_nat {#one_get_nat}

```C
Option(int) get_nat()
```

Read a natural number from standard input, terminated by a
newline. Returns none on end of file (when ctl-d is pressed).

## parse_nat0 {#one_parse_natQzeroE}

```C
Result(int, ParseError) parse_nat0(cstr s)
```

Translate a string into an `int` in the natural number range
including 0 (0 or higher) if possible.

## get_nat0 {#one_get_natQzeroE}

```C
Option(int) get_nat0()
```

Read a natural number or zero from standard input, terminated by a
newline. Returns none on end of file (when ctl-d is pressed).

## parse_float {#one_parse_float}

```C
Result(float, ParseError) parse_float(cstr s)
```

Translate a cstr into an `float` if possible.

## get_float {#one_get_float}

```C
Option(float) get_float()
```

Read a floating point number or zero from standard input,
terminated by a newline. Returns none on end of file (when ctl-d is
pressed).

## new_chars {#one_new_chars}

```C
char* new_chars(size_t len)
```

Allocate and return a new array of `len` char values. Aborts
when there is not enough memory (never returns the NULL
pointer). The slots in the returned array are all initialized to
the '\0' char.

## new_cstrs {#one_new_cstrs}

```C
cstr* new_cstrs(size_t len)
```

Allocate and return a new array of `len` cstr values. Aborts
when there is not enough memory (never returns the NULL
pointer). The slots in the returned array are all initialized to
the NULL pointer.

## new_Option_Strings {#one_new_Option_Strings}

```C
Option(String)* new_Option_Strings(size_t len)
```

Allocate and return a new array of `len` Option(String)
values. Aborts when there is not enough memory (never returns the
NULL pointer). The slots in the returned array are all initialized
to the none value.

## new_ints {#one_new_ints}

```C
int* new_ints(size_t len)
```

Allocate and return a new array of `len` int values. Aborts when
there is not enough memory (never returns the NULL pointer). The
slots in the returned array are all initialized to the value 0.

## new_floats {#one_new_floats}

```C
float* new_floats(size_t len)
```

Allocate and return a new array of `len` float values. Aborts when
there is not enough memory (never returns the NULL pointer). The
slots in the returned array are all initialized to the value 0.

## env_is_true {#one_env_is_true}

```C
bool env_is_true(cstr varname)
```

Return true if the environment variable with the given name is set
to a string that is not "0"

# Generic functions

## print {#two_print}

```C
print(v)
```

Prints the given value for normal text use.

Returns an `int` that when negative signifies an error (check
`errno` for the error in this case), and when positive signifies
the number of bytes written.

Also see `print_debug` and `print_debug_array`, which support more
types, but are not meant for printing output for normal humans.

Members:

```C
CStr              : int print_move_CStr(CStr s);
CStr*             : int print_CStr(const CStr *s);
String            : int print_move_String(String s);
String*           : int print_String(const String *s);
char              : int putchar(int c);
char*             : int print_move_cstr(cstr s);
const CStr*       : int print_CStr(const CStr *s);
const String*     : int print_String(const String *s);
const cstr*       : int print_cstr(const cstr *s);
const double*     : int print_double(const double *x);
const float*      : int print_float(const float *x);
const i64*        : int print_i64(const i64 *n);
const int*        : int print_int(const int *n);
const u32*        : int print_u32(const u32 *n);
const u64*        : int print_u64(const u64 *n);
const u8*         : int print_u8(const u8 *n);
const ucodepoint* : int print_ucodepoint(const ucodepoint *a);
const utf8char*   : int print_utf8char(const utf8char *c);
cstr              : int print_move_cstr(cstr s);
cstr*             : int print_cstr(const cstr *s);
double            : int print_move_double(double x);
double*           : int print_double(const double *x);
float             : int print_move_float(float x);
float*            : int print_float(const float *x);
i64               : int print_move_i64(i64 n);
i64*              : int print_i64(const i64 *n);
int               : int print_move_int(int n);
int*              : int print_int(const int *n);
u32               : int print_move_u32(u32 n);
u32*              : int print_u32(const u32 *n);
u64               : int print_move_u64(u64 n);
u64*              : int print_u64(const u64 *n);
u8                : int print_move_u8(u8 n);
u8*               : int print_u8(const u8 *n);
ucodepoint        : int print_move_ucodepoint(ucodepoint a);
ucodepoint*       : int print_ucodepoint(const ucodepoint *a);
utf8char          : int print_move_utf8char(utf8char c);
utf8char*         : int print_utf8char(const utf8char *c);
```

## println {#two_println}

```C
println(v)
```

Prints the given value for normal text use, followed by a newline
(`"\n"`) for convenience.

Members:

```C
CStr              : int println_move_CStr(CStr v);
CStr*             : int println_CStr(const CStr *v);
String            : int println_move_String(String v);
String*           : int println_String(const String *v);
char              : int println_move_char(char v);
char*             : int println_move_cstr(cstr v);
const CStr*       : int println_CStr(const CStr *v);
const String*     : int println_String(const String *v);
const cstr*       : int println_cstr(const cstr *v);
const double*     : int println_double(const double *v);
const float*      : int println_float(const float *v);
const i64*        : int println_i64(const i64 *v);
const u32*        : int println_u32(const u32 *v);
const u64*        : int println_u64(const u64 *v);
const u8*         : int println_u8(const u8 *v);
const ucodepoint* : int println_ucodepoint(const ucodepoint *v);
const utf8char*   : int println_utf8char(const utf8char *v);
cstr              : int println_move_cstr(cstr v);
cstr*             : int println_cstr(const cstr *v);
double            : int println_move_double(double v);
double*           : int println_double(const double *v);
float             : int println_move_float(float v);
float*            : int println_float(const float *v);
i64               : int println_move_i64(i64 v);
i64*              : int println_i64(const i64 *v);
int               : int println_int(const int *v);
u32               : int println_move_u32(u32 v);
u32*              : int println_u32(const u32 *v);
u64               : int println_move_u64(u64 v);
u64*              : int println_u64(const u64 *v);
u8                : int println_move_u8(u8 v);
u8*               : int println_u8(const u8 *v);
ucodepoint        : int println_move_ucodepoint(ucodepoint v);
ucodepoint*       : int println_ucodepoint(const ucodepoint *v);
utf8char          : int println_move_utf8char(utf8char v);
utf8char*         : int println_utf8char(const utf8char *v);
```

## print_debug {#two_print_debug}

```C
print_debug(v)
```

Prints the given value in a programmer's view, for debugging
purposes.

Returns an `int` that when negative signifies an error (check
`errno` for the error in this case), and when positive signifies
the number of bytes written.

See `print` for printing as normal text, not for debugging, and
`print_debug_array` for printing arrays.

Members:

```C
CStr                           : int print_debug_move_CStr(CStr s);
CStr*                          : int print_debug_CStr(const CStr *s);
Color                          : int print_debug_move_Color(Color v);
Color*                         : int print_debug_Color(const Color *v);
Option(CStr)                   : int print_debug_move_Option_CStr(Option_CStr s);
Option(CStr)*                  : int print_debug_Option_CStr(const Option_CStr *s);
Option(String)                 : int print_debug_move_Option_String(Option_String s);
Option(String)*                : int print_debug_Option_String(const Option_String *s);
Option(cstr)                   : int print_debug_move_Option_cstr(Option_cstr s);
Option(cstr)*                  : int print_debug_Option_cstr(const Option_cstr *s);
Option(float)                  : int print_debug_move_Option_float(Option_float s);
Option(float)*                 : int print_debug_Option_float(const Option_float *s);
Option(int)                    : int print_debug_move_Option_int(Option_int s);
Option(int)*                   : int print_debug_Option_int(const Option_int *s);
Rect2(double)                  : int print_debug_move_Rect2_double(Rect2_double s);
Rect2(double)*                 : int print_debug_Rect2_double(const Rect2_double *s);
Rect2(float)                   : int print_debug_move_Rect2_float(Rect2_float s);
Rect2(float)*                  : int print_debug_Rect2_float(const Rect2_float *s);
Rect2(int)                     : int print_debug_move_Rect2_int(Rect2_int s);
Rect2(int)*                    : int print_debug_Rect2_int(const Rect2_int *s);
Result(String, SystemError)    : int print_debug_move_Result_String__SystemError( Result_String__SystemError s);
Result(int, ParseError)        : int print_debug_move_Result_int__ParseError( Result_int__ParseError s);
Result(int, ParseError)*       : int print_debug_Result_int__ParseError( const Result_int__ParseError *s);
String                         : int print_debug_move_String(String s);
String*                        : int print_debug_String(const String *s);
SystemError                    : int print_debug_SystemError(const SystemError *v);
UnicodeError*                  : int print_debug_UnicodeError(const UnicodeError *e);
Vec(CStr)                      : int print_debug_move_Vec_CStr(Vec_CStr self);
Vec(CStr)*                     : int print_debug_Vec_CStr(const Vec_CStr *self);
Vec(Rect2(float))              : int print_debug_move_Vec_Rect2_float(Vec_Rect2_float self);
Vec(Rect2(float))*             : int print_debug_Vec_Rect2_float(const Vec_Rect2_float *self);
Vec(Vec2(float))               : int print_debug_move_Vec_Vec2_float(Vec_Vec2_float self);
Vec(Vec2(float))*              : int print_debug_Vec_Vec2_float(const Vec_Vec2_float *self);
Vec(Vec2(int))                 : int print_debug_move_Vec_Vec2_int(Vec_Vec2_int self);
Vec(Vec2(int))*                : int print_debug_Vec_Vec2_int(const Vec_Vec2_int *self);
Vec(Vec3(int))                 : int print_debug_move_Vec_Vec3_int(Vec_Vec3_int self);
Vec(Vec3(int))*                : int print_debug_Vec_Vec3_int(const Vec_Vec3_int *self);
Vec(char)                      : int print_debug_move_Vec_char(Vec_char self);
Vec(char)*                     : int print_debug_Vec_char(const Vec_char *self);
Vec(cstr)                      : int print_debug_move_Vec_cstr(Vec_cstr self);
Vec(cstr)*                     : int print_debug_Vec_cstr(const Vec_cstr *self);
Vec(double)                    : int print_debug_move_Vec_double(Vec_double self);
Vec(double)*                   : int print_debug_Vec_double(const Vec_double *self);
Vec(float)                     : int print_debug_move_Vec_float(Vec_float self);
Vec(float)*                    : int print_debug_Vec_float(const Vec_float *self);
Vec(int)                       : int print_debug_move_Vec_int(Vec_int self);
Vec(int)*                      : int print_debug_Vec_int(const Vec_int *self);
Vec(ucodepoint)                : int print_debug_move_Vec_ucodepoint(Vec_ucodepoint self);
Vec(ucodepoint)*               : int print_debug_Vec_ucodepoint(const Vec_ucodepoint *self);
Vec(utf8char)                  : int print_debug_move_Vec_utf8char(Vec_utf8char self);
Vec(utf8char)*                 : int print_debug_Vec_utf8char(const Vec_utf8char *self);
Vec2(double)                   : int print_debug_move_Vec2_double(Vec2_double a);
Vec2(double)*                  : int print_debug_Vec2_double(const Vec2_double *a);
Vec2(float)                    : int print_debug_move_Vec2_float(Vec2_float a);
Vec2(float)*                   : int print_debug_Vec2_float(const Vec2_float *a);
Vec2(int)                      : int print_debug_move_Vec2_int(Vec2_int a);
Vec2(int)*                     : int print_debug_Vec2_int(const Vec2_int *a);
Vec2(u32)                      : int print_debug_move_Vec2_u32(Vec2_u32 a);
Vec2(u32)*                     : int print_debug_Vec2_u32(const Vec2_u32 *a);
Vec3(double)                   : int print_debug_move_Vec3_double(Vec3_double a);
Vec3(double)*                  : int print_debug_Vec3_double(const Vec3_double *a);
Vec3(float)                    : int print_debug_move_Vec3_float(Vec3_float a);
Vec3(float)*                   : int print_debug_Vec3_float(const Vec3_float *a);
Vec3(int)                      : int print_debug_move_Vec3_int(Vec3_int a);
Vec3(int)*                     : int print_debug_Vec3_int(const Vec3_int *a);
Vec3(u32)                      : int print_debug_move_Vec3_u32(Vec3_u32 a);
Vec3(u32)*                     : int print_debug_Vec3_u32(const Vec3_u32 *a);
VertexRenderer*                : int print_debug_VertexRenderer(const VertexRenderer *self);
bool                           : int print_debug_bool(const bool *v);
char                           : int print_debug_char(const char *c);
char*                          : int print_debug_move_cstr(cstr s);
char**                         : int print_debug_cstr(const cstr *s);
const CStr*                    : int print_debug_CStr(const CStr *s);
const Color*                   : int print_debug_Color(const Color *v);
const Option(CStr)*            : int print_debug_Option_CStr(const Option_CStr *s);
const Option(String)*          : int print_debug_Option_String(const Option_String *s);
const Option(cstr)*            : int print_debug_Option_cstr(const Option_cstr *s);
const Option(float)*           : int print_debug_Option_float(const Option_float *s);
const Option(int)*             : int print_debug_Option_int(const Option_int *s);
const Result(int, ParseError)* : int print_debug_Result_int__ParseError( const Result_int__ParseError *s);
const String*                  : int print_debug_String(const String *s);
const UnicodeError*            : int print_debug_UnicodeError(const UnicodeError *e);
const Vec(CStr)*               : int print_debug_Vec_CStr(const Vec_CStr *self);
const Vec(char)*               : int print_debug_Vec_char(const Vec_char *self);
const Vec(cstr)*               : int print_debug_Vec_cstr(const Vec_cstr *self);
const Vec(double)*             : int print_debug_Vec_double(const Vec_double *self);
const Vec(float)*              : int print_debug_Vec_float(const Vec_float *self);
const Vec(int)*                : int print_debug_Vec_int(const Vec_int *self);
const Vec(ucodepoint)*         : int print_debug_Vec_ucodepoint(const Vec_ucodepoint *self);
const Vec(utf8char)*           : int print_debug_Vec_utf8char(const Vec_utf8char *self);
const cstr*                    : int print_debug_cstr(const cstr *s);
const double*                  : int print_double(const double *x);
const float*                   : int print_float(const float *x);
const i64*                     : int print_i64(const i64 *n);
const int*                     : int print_int(const int *n);
const mutslice(CStr)*          : int print_debug_mutslice_CStr(const mutslice_CStr *self);
const mutslice(char)*          : int print_debug_mutslice_char(const mutslice_char *self);
const mutslice(cstr)*          : int print_debug_mutslice_cstr(const mutslice_cstr *self);
const mutslice(int)*           : int print_debug_mutslice_int(const mutslice_int *self);
const mutslice(ucodepoint)*    : int print_debug_mutslice_ucodepoint(const mutslice_ucodepoint *self);
const mutslice(utf8char)*      : int print_debug_mutslice_utf8char(const mutslice_utf8char *self);
const slice(CStr)*             : int print_debug_slice_CStr(const slice_CStr *self);
const slice(char)*             : int print_debug_slice_char(const slice_char *self);
const slice(cstr)*             : int print_debug_slice_cstr(const slice_cstr *self);
const slice(int)*              : int print_debug_slice_int(const slice_int *self);
const slice(ucodepoint)*       : int print_debug_slice_ucodepoint(const slice_ucodepoint *self);
const slice(utf8char)*         : int print_debug_slice_utf8char(const slice_utf8char *self);
const u32*                     : int print_u32(const u32 *n);
const u64*                     : int print_u64(const u64 *n);
const u8*                      : int print_u8(const u8 *n);
const ucodepoint*              : int print_debug_ucodepoint(const ucodepoint *a);
const utf8char*                : int print_debug_utf8char(const utf8char *c);
cstr                           : int print_debug_move_cstr(cstr s);
cstr*                          : int print_debug_cstr(const cstr *s);
double                         : int print_move_double(double x);
double*                        : int print_double(const double *x);
float                          : int print_move_float(float x);
float*                         : int print_float(const float *x);
i64                            : int print_move_i64(i64 n);
i64*                           : int print_i64(const i64 *n);
int                            : int print_move_int(int n);
int*                           : int print_int(const int *n);
mutslice(CStr)                 : int print_debug_move_mutslice_CStr(mutslice_CStr self);
mutslice(CStr)*                : int print_debug_mutslice_CStr(const mutslice_CStr *self);
mutslice(Vec2(int))            : int print_debug_move_mutslice_Vec2_int(mutslice_Vec2_int self);
mutslice(Vec2(int))*           : int print_debug_mutslice_Vec2_int(const mutslice_Vec2_int *self);
mutslice(char)                 : int print_debug_move_mutslice_char(mutslice_char self);
mutslice(char)*                : int print_debug_mutslice_char(const mutslice_char *self);
mutslice(cstr)                 : int print_debug_move_mutslice_cstr(mutslice_cstr self);
mutslice(cstr)*                : int print_debug_mutslice_cstr(const mutslice_cstr *self);
mutslice(int)                  : int print_debug_move_mutslice_int(mutslice_int self);
mutslice(int)*                 : int print_debug_mutslice_int(const mutslice_int *self);
mutslice(ucodepoint)           : int print_debug_move_mutslice_ucodepoint(mutslice_ucodepoint self);
mutslice(ucodepoint)*          : int print_debug_mutslice_ucodepoint(const mutslice_ucodepoint *self);
mutslice(utf8char)             : int print_debug_move_mutslice_utf8char(mutslice_utf8char self);
mutslice(utf8char)*            : int print_debug_mutslice_utf8char(const mutslice_utf8char *self);
slice(CStr)                    : int print_debug_move_slice_CStr(slice_CStr self);
slice(CStr)*                   : int print_debug_slice_CStr(const slice_CStr *self);
slice(Rect2(float))            : int print_debug_move_slice_Rect2_float(slice_Rect2_float self);
slice(Rect2(float))*           : int print_debug_slice_Rect2_float(const slice_Rect2_float *self);
slice(Vec2(float))             : int print_debug_move_slice_Vec2_float(slice_Vec2_float self);
slice(Vec2(float))*            : int print_debug_slice_Vec2_float(const slice_Vec2_float *self);
slice(Vec2(int))               : int print_debug_move_slice_Vec2_int(slice_Vec2_int self);
slice(Vec2(int))*              : int print_debug_slice_Vec2_int(const slice_Vec2_int *self);
slice(Vec3(int))               : int print_debug_move_slice_Vec3_int(slice_Vec3_int self);
slice(Vec3(int))*              : int print_debug_slice_Vec3_int(const slice_Vec3_int *self);
slice(char)                    : int print_debug_move_slice_char(slice_char self);
slice(char)*                   : int print_debug_slice_char(const slice_char *self);
slice(cstr)                    : int print_debug_move_slice_cstr(slice_cstr self);
slice(cstr)*                   : int print_debug_slice_cstr(const slice_cstr *self);
slice(int)                     : int print_debug_move_slice_int(slice_int self);
slice(int)*                    : int print_debug_slice_int(const slice_int *self);
slice(ucodepoint)              : int print_debug_move_slice_ucodepoint(slice_ucodepoint self);
slice(ucodepoint)*             : int print_debug_slice_ucodepoint(const slice_ucodepoint *self);
slice(utf8char)                : int print_debug_move_slice_utf8char(slice_utf8char self);
slice(utf8char)*               : int print_debug_slice_utf8char(const slice_utf8char *self);
u32                            : int print_move_u32(u32 n);
u32*                           : int print_u32(const u32 *n);
u64                            : int print_move_u64(u64 n);
u64*                           : int print_u64(const u64 *n);
u8                             : int print_move_u8(u8 n);
u8*                            : int print_u8(const u8 *n);
ucodepoint                     : int print_debug_move_ucodepoint(ucodepoint a);
ucodepoint*                    : int print_debug_ucodepoint(const ucodepoint *a);
utf8char                       : int print_debug_move_utf8char(utf8char c);
utf8char*                      : int print_debug_utf8char(const utf8char *c);
```

## print_debug_array {#two_print_debug_array}

```C
print_debug_array(v, len)
```

Prints the given array in a programmer's view, for debugging
purposes.

Returns an `int` that when negative signifies an error (check
`errno` for the error in this case), and when positive signifies
the number of bytes written.

See `print_debug` for printing non-array values.

Members:

```C
Option(String)* : int print_debug_Option_Strings(const Option(String)* ary, size_t len);
char*           : int print_debug_chars(const char* ary, size_t len);
cstr*           : int print_debug_cstrs(const cstr* ary, size_t len);
float*          : int print_debug_floats(const float* ary, size_t len);
int*            : int print_debug_ints(const int* ary, size_t len);
```

## drop {#two_drop}

```C
drop(v)
```

Frees the resources held by the given value (including resources
held by contained values, recursively, unlike the `free` function).

Members:

```C
CFile                : void drop_CFile(CFile f);
CStr                 : void drop_CStr(CStr s);
CStrError            : void drop_CStrError(UNUSED CStrError e);
Option(CStr)         : inline void drop_Option_CStr(Option_CStr s);
Option(String)       : inline void drop_Option_String(Option_String s);
Option(cstr)         : inline void drop_Option_cstr(Option_cstr s);
Option(double)       : inline void drop_Option_double(Option_double s);
Option(float)        : inline void drop_Option_float(Option_float s);
Option(int)          : inline void drop_Option_int(Option_int s);
ParseError           : void drop_ParseError(UNUSED ParseError e);
String               : void drop_String(String s);
SystemError          : void drop_SystemError(UNUSED SystemError e);
UnicodeError         : void drop_UnicodeError(UnicodeError e);
Vec(CStr)            : void drop_Vec_CStr(Vec_CStr self);
Vec(Rect2(float))    : void drop_Vec_Rect2_float(Vec_Rect2_float self);
Vec(Vec2(double))    : void drop_Vec_Vec2_double(Vec_Vec2_double self);
Vec(Vec2(float))     : void drop_Vec_Vec2_float(Vec_Vec2_float self);
Vec(Vec2(int))       : void drop_Vec_Vec2_int(Vec_Vec2_int self);
Vec(Vec3(int))       : void drop_Vec_Vec3_int(Vec_Vec3_int self);
Vec(char)            : void drop_Vec_char(Vec_char self);
Vec(cstr)            : void drop_Vec_cstr(Vec_cstr self);
Vec(double)          : void drop_Vec_double(Vec_double self);
Vec(float)           : void drop_Vec_float(Vec_float self);
Vec(int)             : void drop_Vec_int(Vec_int self);
Vec(ucodepoint)      : void drop_Vec_ucodepoint(Vec_ucodepoint self);
Vec(utf8char)        : void drop_Vec_utf8char(Vec_utf8char self);
Vec2(double)*        : void free(void *ptr);
Vec2(float)*         : void free(void *ptr);
Vec2(int)*           : void free(void *ptr);
Vec3(double)*        : void free(void *ptr);
Vec3(float)*         : void free(void *ptr);
Vec3(int)*           : void free(void *ptr);
VecError             : void drop_VecError(UNUSED VecError e);
VertexRenderer       : void drop_VertexRenderer(VertexRenderer self);
char*                : void drop_cstr(__attribute__ ((unused)) cstr s);
const char*          : void drop_cstr(__attribute__ ((unused)) cstr s);
float*               : void free(void *ptr);
int*                 : void free(void *ptr);
mutslice(CStr)       : void drop_mutslice_CStr(__attribute__ ((unused)) mutslice_CStr self);
mutslice(cstr)       : void drop_mutslice_cstr(__attribute__ ((unused)) mutslice_cstr self);
mutslice(ucodepoint) : void drop_mutslice_ucodepoint(__attribute__ ((unused)) mutslice_ucodepoint self);
mutslice(utf8char)   : void drop_mutslice_utf8char(__attribute__ ((unused)) mutslice_utf8char self);
slice(CStr)          : void drop_slice_CStr(__attribute__ ((unused)) slice_CStr self);
slice(cstr)          : void drop_slice_cstr(__attribute__ ((unused)) slice_cstr self);
slice(ucodepoint)    : void drop_slice_ucodepoint(__attribute__ ((unused)) slice_ucodepoint self);
slice(utf8char)      : void drop_slice_utf8char(__attribute__ ((unused)) slice_utf8char self);
ucodepoint           : void drop_ucodepoint(__attribute__ ((unused)) ucodepoint c);
```

## resize {#two_resize}

```C
resize(v, oldlen, newlen)
```

Expects an array as the first argument, and the current length of
the array and the desired new length. Returns a new array of the
desired new length. If the new length is shorter than the old
length, the slots that are freed are `drop`ped, if the new length
is larger, then the new slots are filled in with blanks (zero
values, NULL pointers, or similar).

Members:

```C
Option(String)* : Option(String)* resize_Option_Strings(
 Option(String)* ary, size_t oldlen, size_t newlen
 );
cstr*           : cstr* resize_cstrs(cstr* ary, size_t oldlen, size_t newlen);
float*          : float* resize_floats(float* ary, size_t oldlen, size_t newlen);
int*            : int* resize_ints(int* ary, size_t oldlen, size_t newlen);
```

## drop_array {#two_drop_array}

```C
drop_array(v, len)
```

Frees the resources held by the given array,
including all the values contained in the array (including
resources held by contained values, recursively). For arrays
holding pointers, array slots containing the NULL pointer are
skipped.

Members:

```C
Option(String)* : void drop_Option_Strings(Option(String)* ary, size_t len);
cstr*           : void drop_cstrs(cstr* ary, size_t len);
```

## equal {#two_equal}

```C
equal(a, b)
```

Takes two values of the same type and returns a `bool`. Returns
`true` if `a` and `b` are structurally equivalent.

Members:

```C
CStr*                              : bool equal_CStr(const CStr *a, const CStr *b);
Color                              : bool equal_move_Color(Color a, Color b);
Color*                             : bool equal_Color(const Color *a, const Color *b);
Option(String)*                    : bool equal_Option_String(const Option_String *a, const Option_String *b);
Option(char)                       : bool equal_move_Option_char(Option_char a, Option_char b);
Option(char)*                      : bool equal_Option_char(const Option_char *a, const Option_char *b);
Option(cstr)*                      : bool equal_Option_cstr(const Option_cstr *a, const Option_cstr *b);
Option(float)*                     : bool equal_Option_float(const Option_float *a, const Option_float *b);
Option(int)*                       : bool equal_Option_int(const Option_int *a, const Option_int *b);
Option(ucodepoint)                 : bool equal_move_Option_ucodepoint(Option_ucodepoint a, Option_ucodepoint b);
Option(ucodepoint)*                : bool equal_Option_ucodepoint(const Option_ucodepoint *a, const Option_ucodepoint *b);
Option(utf8char)                   : bool equal_move_Option_utf8char(Option_utf8char a, Option_utf8char b);
Option(utf8char)*                  : bool equal_Option_utf8char(const Option_utf8char *a, const Option_utf8char *b);
Result(String, SystemError)*       : bool equal_Result_String__SystemError(const Result_String__SystemError *a, const Result_String__SystemError *b);
Result(int, ParseError)*           : bool equal_Result_int__ParseError(const Result_int__ParseError *a, const Result_int__ParseError *b);
String*                            : bool equal_String(const String *a, const String *b);
Vec(CStr)*                         : bool equal_Vec_CStr(const Vec_CStr *a, const Vec_CStr *b);
Vec(Rect2(float))*                 : bool equal_Vec_Rect2_float(const Vec_Rect2_float *a, const Vec_Rect2_float *b);
Vec(Vec2(double))*                 : bool equal_Vec_Vec2_double(const Vec_Vec2_double *a, const Vec_Vec2_double *b);
Vec(Vec2(float))*                  : bool equal_Vec_Vec2_float(const Vec_Vec2_float *a, const Vec_Vec2_float *b);
Vec(Vec2(int))*                    : bool equal_Vec_Vec2_int(const Vec_Vec2_int *a, const Vec_Vec2_int *b);
Vec(Vec3(int))*                    : bool equal_Vec_Vec3_int(const Vec_Vec3_int *a, const Vec_Vec3_int *b);
Vec(char)*                         : bool equal_Vec_char(const Vec_char *a, const Vec_char *b);
Vec(cstr)*                         : bool equal_Vec_cstr(const Vec_cstr *a, const Vec_cstr *b);
Vec(double)*                       : bool equal_Vec_double(const Vec_double *a, const Vec_double *b);
Vec(float)*                        : bool equal_Vec_float(const Vec_float *a, const Vec_float *b);
Vec(int)*                          : bool equal_Vec_int(const Vec_int *a, const Vec_int *b);
Vec(ucodepoint)*                   : bool equal_Vec_ucodepoint(const Vec_ucodepoint *a, const Vec_ucodepoint *b);
Vec(utf8char)*                     : bool equal_Vec_utf8char(const Vec_utf8char *a, const Vec_utf8char *b);
bool                               : bool equal_move_bool(bool a, bool b);
bool*                              : bool equal_bool(const bool *a, const bool *b);
char                               : bool equal_move_char(const char a, const char b);
const CStr*                        : bool equal_CStr(const CStr *a, const CStr *b);
const Color*                       : bool equal_Color(const Color *a, const Color *b);
const Option(String)*              : bool equal_Option_String(const Option_String *a, const Option_String *b);
const Option(char)*                : bool equal_Option_char(const Option_char *a, const Option_char *b);
const Option(cstr)*                : bool equal_Option_cstr(const Option_cstr *a, const Option_cstr *b);
const Option(float)*               : bool equal_Option_float(const Option_float *a, const Option_float *b);
const Option(int)*                 : bool equal_Option_int(const Option_int *a, const Option_int *b);
const Option(ucodepoint)*          : bool equal_Option_ucodepoint(const Option_ucodepoint *a, const Option_ucodepoint *b);
const Option(utf8char)*            : bool equal_Option_utf8char(const Option_utf8char *a, const Option_utf8char *b);
const Result(String, SystemError)* : bool equal_Result_String__SystemError(const Result_String__SystemError *a, const Result_String__SystemError *b);
const Result(int, ParseError)*     : bool equal_Result_int__ParseError(const Result_int__ParseError *a, const Result_int__ParseError *b);
const String*                      : bool equal_String(const String *a, const String *b);
const Vec(CStr)*                   : bool equal_Vec_CStr(const Vec_CStr *a, const Vec_CStr *b);
const Vec(char)*                   : bool equal_Vec_char(const Vec_char *a, const Vec_char *b);
const Vec(cstr)*                   : bool equal_Vec_cstr(const Vec_cstr *a, const Vec_cstr *b);
const Vec(double)*                 : bool equal_Vec_double(const Vec_double *a, const Vec_double *b);
const Vec(float)*                  : bool equal_Vec_float(const Vec_float *a, const Vec_float *b);
const Vec(int)*                    : bool equal_Vec_int(const Vec_int *a, const Vec_int *b);
const Vec(ucodepoint)*             : bool equal_Vec_ucodepoint(const Vec_ucodepoint *a, const Vec_ucodepoint *b);
const Vec(utf8char)*               : bool equal_Vec_utf8char(const Vec_utf8char *a, const Vec_utf8char *b);
const bool*                        : bool equal_bool(const bool *a, const bool *b);
const cstr*                        : bool equal_cstr(const cstr *a, const cstr *b);
const double*                      : bool equal_double(const double *a, const double *b);
const float*                       : bool equal_float(const float *a, const float *b);
const int*                         : bool equal_int(const int *a, const int *b);
const ucodepoint*                  : bool equal_ucodepoint(const ucodepoint *a, const ucodepoint *b);
const utf8char*                    : bool equal_utf8char(const utf8char *a, const utf8char *b);
cstr                               : bool equal_move_cstr(cstr a, cstr b);
cstr*                              : bool equal_cstr(const cstr *a, const cstr *b);
double                             : bool equal_move_double(const double a, const double b);
double*                            : bool equal_double(const double *a, const double *b);
float                              : bool equal_move_float(const float a, const float b);
float*                             : bool equal_float(const float *a, const float *b);
int                                : bool equal_move_int(const int a, const int b);
int*                               : bool equal_int(const int *a, const int *b);
slice(CStr)*                       : bool equal_slice_CStr(const slice_CStr *a, const slice_CStr *b);
slice(Rect2(float))*               : bool equal_slice_Rect2_float(const slice_Rect2_float *a, const slice_Rect2_float *b);
slice(Vec2(double))*               : bool equal_slice_Vec2_double(const slice_Vec2_double *a, const slice_Vec2_double *b);
slice(Vec2(float))*                : bool equal_slice_Vec2_float(const slice_Vec2_float *a, const slice_Vec2_float *b);
slice(Vec2(int))*                  : bool equal_slice_Vec2_int(const slice_Vec2_int *a, const slice_Vec2_int *b);
slice(Vec3(int))*                  : bool equal_slice_Vec3_int(const slice_Vec3_int *a, const slice_Vec3_int *b);
slice(char)*                       : bool equal_slice_char(const slice_char *a, const slice_char *b);
slice(cstr)*                       : bool equal_slice_cstr(const slice_cstr *a, const slice_cstr *b);
slice(double)*                     : bool equal_slice_double(const slice_double *a, const slice_double *b);
slice(float)*                      : bool equal_slice_float(const slice_float *a, const slice_float *b);
slice(int)*                        : bool equal_slice_int(const slice_int *a, const slice_int *b);
slice(ucodepoint)*                 : bool equal_slice_ucodepoint(const slice_ucodepoint *a, const slice_ucodepoint *b);
slice(utf8char)*                   : bool equal_slice_utf8char(const slice_utf8char *a, const slice_utf8char *b);
ucodepoint                         : bool equal_move_ucodepoint(ucodepoint a, ucodepoint b);
ucodepoint*                        : bool equal_ucodepoint(const ucodepoint *a, const ucodepoint *b);
utf8char                           : bool equal_move_utf8char(utf8char a, utf8char b);
utf8char*                          : bool equal_utf8char(const utf8char *a, const utf8char *b);
```

## some {#two_some}

```C
some(v)
```

Takes a value of some type `T` and returns a `some` variant of
`Option(T)` containing the value.

Members:

```C
CStr        : Option_CStr some_CStr(CStr val);
String      : Option_String some_String(String val);
Vec2(float) : Option_Vec2_float some_Vec2_float(Vec2_float val);
cstr        : Option_cstr some_cstr(cstr val);
double      : Option_double some_double(double val);
float       : Option_float some_float(float val);
i64         : Option_i64 some_i64(i64 val);
int         : Option_int some_int(int val);
u64         : Option_u64 some_u64(u64 val);
u8          : Option_u8 some_u8(u8 val);
```

## none {#two_none}

```C
none(T)
```

Returns the none variant of `Option(T)` for the given
T. Equivalent to `none_T()` using the type name of T, but
`none(T)` allows T to also be a `typeof` expression.

Members:

```C
CStr   : Option_CStr none_CStr();
String : Option_String none_String();
cstr   : Option_cstr none_cstr();
double : Option_double none_double();
float  : Option_float none_float();
i64    : Option_i64 none_i64();
int    : Option_int none_int();
u64    : Option_u64 none_u64();
u8     : Option_u8 none_u8();
```

## unwrap {#two_unwrap}

```C
unwrap(v)
```

Takes a wrapper for some type `T` (like `Option(T)`, or `Result(T,
E)`) and returns the contained value of type `T` if possible, or
aborts if not possible. This moves the value, i.e. the wrapper
is consumed.

Example:

```C
Option(CStr) maybe_name = get_CStr();
// maybe_name can be a `none(CStr)` or e.g. `some("Alex")`.
CStr name = unwrap(maybe_name);
// Now we're guaranteed to have a CStr in `name`, "Alex" if we
// had the second case above. But if `maybe_name` was a none
// then the program has terminated by now instead.
```

Members:

```C
Option(CStr)                          : inline CStr unwrap_Option_CStr(Option_CStr s);
Option(String)                        : inline String unwrap_Option_String(Option_String s);
Option(char)                          : inline char unwrap_Option_char(Option_char s);
Option(cstr)                          : inline cstr unwrap_Option_cstr(Option_cstr s);
Option(double)                        : inline double unwrap_Option_double(Option_double s);
Option(float)                         : inline float unwrap_Option_float(Option_float s);
Option(i64)                           : inline i64 unwrap_Option_i64(Option_i64 s);
Option(int)                           : inline int unwrap_Option_int(Option_int s);
Option(u64)                           : inline u64 unwrap_Option_u64(Option_u64 s);
Option(u8)                            : inline u8 unwrap_Option_u8(Option_u8 s);
Option(ucodepoint)                    : inline ucodepoint unwrap_Option_ucodepoint(Option_ucodepoint s);
Option(utf8char)                      : inline utf8char unwrap_Option_utf8char(Option_utf8char s);
Result(String, SystemError)           : String unwrap_Result_String__SystemError(Result_String__SystemError s);
Result(String, UnicodeError)          : String unwrap_Result_String__UnicodeError(Result_String__UnicodeError s);
Result(Unit, UnicodeError)            : Unit unwrap_Result_Unit__UnicodeError(Result_Unit__UnicodeError s);
Result(Vec(ucodepoint), UnicodeError) : Vec_ucodepoint unwrap_Result_Vec_ucodepoint__UnicodeError(Result_Vec_ucodepoint__UnicodeError s);
Result(Vec(utf8char), UnicodeError)   : Vec_utf8char unwrap_Result_Vec_utf8char__UnicodeError(Result_Vec_utf8char__UnicodeError s);
Result(float, ParseError)             : float unwrap_Result_float__ParseError(Result_float__ParseError s);
Result(int, ParseError)               : int unwrap_Result_int__ParseError(Result_int__ParseError s);
Result(size_t, UnicodeError)          : size_t unwrap_Result_size_t__UnicodeError(Result_size_t__UnicodeError s);
Result(ucodepoint, UnicodeError)      : ucodepoint unwrap_Result_ucodepoint__UnicodeError(Result_ucodepoint__UnicodeError s);
```

## unwrap_or {#two_unwrap_or}

```C
unwrap_or(v)
```

Takes a wrapper for some type `T` (like `Option(T)`, or `Result(T,
E)`) and returns the contained value of type `T` if possible, or
aborts if not possible. This moves the value, i.e. the wrapper
is consumed.

Example:

```C
Option(CStr) maybe_name = get_CStr();
// maybe_name can be a `none(CStr)` or e.g. `some("Alex")`.
CStr name = unwrap_or(maybe_name, CStr_from_cstr_unsafe("no name"));
// Now we're guaranteed to have a CStr in `name`, "Alex" if we
// had the second case above, "no name" in the first.
```

Members:

```C
Option(CStr)                          : inline CStr unwrap_or_Option_CStr(Option_CStr s, CStr defaultval);
Option(String)                        : inline String unwrap_or_Option_String(Option_String s, String defaultval);
Option(char)                          : inline char unwrap_or_Option_char(Option_char s, char defaultval);
Option(cstr)                          : inline cstr unwrap_or_Option_cstr(Option_cstr s, cstr defaultval);
Option(double)                        : inline double unwrap_or_Option_double(Option_double s, double defaultval);
Option(float)                         : inline float unwrap_or_Option_float(Option_float s, float defaultval);
Option(i64)                           : inline i64 unwrap_or_Option_i64(Option_i64 s, i64 defaultval);
Option(int)                           : inline int unwrap_or_Option_int(Option_int s, int defaultval);
Option(u64)                           : inline u64 unwrap_or_Option_u64(Option_u64 s, u64 defaultval);
Option(u8)                            : inline u8 unwrap_or_Option_u8(Option_u8 s, u8 defaultval);
Option(ucodepoint)                    : inline ucodepoint unwrap_or_Option_ucodepoint(Option_ucodepoint s, ucodepoint defaultval);
Option(utf8char)                      : inline utf8char unwrap_or_Option_utf8char(Option_utf8char s, utf8char defaultval);
Result(String, SystemError)           : inline String unwrap_or_Result_String__SystemError(Result_String__SystemError s, String defaultval);
Result(String, UnicodeError)          : inline String unwrap_or_Result_String__UnicodeError(Result_String__UnicodeError s, String defaultval);
Result(Unit, UnicodeError)            : inline Unit unwrap_or_Result_Unit__UnicodeError(Result_Unit__UnicodeError s, Unit defaultval);
Result(Vec(ucodepoint), UnicodeError) : inline Vec_ucodepoint unwrap_or_Result_Vec_ucodepoint__UnicodeError(Result_Vec_ucodepoint__UnicodeError s, Vec_ucodepoint defaultval);
Result(Vec(utf8char), UnicodeError)   : inline Vec_utf8char unwrap_or_Result_Vec_utf8char__UnicodeError(Result_Vec_utf8char__UnicodeError s, Vec_utf8char defaultval);
Result(float, ParseError)             : inline float unwrap_or_Result_float__ParseError(Result_float__ParseError s, float defaultval);
Result(int, ParseError)               : inline int unwrap_or_Result_int__ParseError(Result_int__ParseError s, int defaultval);
Result(size_t, UnicodeError)          : inline size_t unwrap_or_Result_size_t__UnicodeError(Result_size_t__UnicodeError s, size_t defaultval);
Result(ucodepoint, UnicodeError)      : inline ucodepoint unwrap_or_Result_ucodepoint__UnicodeError(Result_ucodepoint__UnicodeError s, ucodepoint defaultval);
```

## deref {#two_deref}

```C
deref(v)
```

Dereferencing a wrapper type ('smart pointer') to the simpler
contained type; the result is of a reference type (not owned).

Example:

```C
CStr s = unwrap(filecontents_CStr(path));
cstr s1 = deref(&s);
```

Members:

```C
CStr*              : cstr deref_CStr(const CStr *s);
Vec(Rect2(float))* : slice_Rect2_float deref_Vec_Rect2_float(const Vec_Rect2_float *self);
Vec(Vec2(double))* : slice_Vec2_double deref_Vec_Vec2_double(const Vec_Vec2_double *self);
Vec(Vec2(float))*  : slice_Vec2_float deref_Vec_Vec2_float(const Vec_Vec2_float *self);
Vec(Vec2(int))*    : slice_Vec2_int deref_Vec_Vec2_int(const Vec_Vec2_int *self);
Vec(Vec3(int))*    : slice_Vec3_int deref_Vec_Vec3_int(const Vec_Vec3_int *self);
```

## type_name {#two_type_name}

```C
type_name(e)
```

Returns the name of the type of `e` as a string constant (cstr).

Members:

```C
Option(String)              : "Option(String)";
Option(cstr)                : "Option(cstr)";
Option(double)              : "Option(double)";
Option(float)               : "Option(float)";
Option(i64)                 : "Option(i64)";
Option(int)                 : "Option(int)";
Option(u64)                 : "Option(u64)";
Option(u8)                  : "Option(u8)";
Rect2(double)               : "Rect2(double)";
Rect2(float)                : "Rect2(float)";
Rect2(int)                  : "Rect2(int)";
Result(String, SystemError) : "Result(String, SystemError)";
Result(int, ParseError)     : "Result(int, ParseError)";
String                      : "String";
Vec(CStr)                   : "Vec(CStr)";
Vec(char)                   : "Vec(char)";
Vec(cstr)                   : "Vec(cstr)";
Vec(double)                 : "Vec(double)";
Vec(float)                  : "Vec(float)";
Vec(int)                    : "Vec(int)";
Vec(ucodepoint)             : "Vec(ucodepoint)";
Vec(utf8char)               : "Vec(utf8char)";
char*                       : "char*";
cstr                        : "cstr";
double                      : "double";
float                       : "float";
i64                         : "i64";
int                         : "int";
mutslice(CStr)              : "mutslice(CStr)";
mutslice(cstr)              : "mutslice(cstr)";
mutslice(ucodepoint)        : "mutslice(ucodepoint)";
mutslice(utf8char)          : "mutslice(utf8char)";
slice(CStr)                 : "slice(CStr)";
slice(cstr)                 : "slice(cstr)";
slice(ucodepoint)           : "slice(ucodepoint)";
slice(utf8char)             : "slice(utf8char)";
u64                         : "u64";
u8                          : "u8";
ucodepoint                  : "ucodepoint";
unsigned int                : "uint";
```

## equal_array {#two_equal_array}

```C
equal_array(array1, len1, array2, len2)
```

Returns true iff len1 == len2 and for every index,
`equal(array1[i], array2[i])` is true.

Members:

```C
String : bool equal_array_String(String* a, size_t alen, String* b, size_t blen);
char   : bool equal_array_char(char* a, size_t alen, char* b, size_t blen);
cstr   : bool equal_array_cstr(cstr* a, size_t alen, cstr* b, size_t blen);
double : bool equal_array_double(double* a, size_t alen, double* b, size_t blen);
float  : bool equal_array_float(float* a, size_t alen, float* b, size_t blen);
i64    : bool equal_array_i64(i64* a, size_t alen, i64* b, size_t blen);
int    : bool equal_array_int(int* a, size_t alen, int* b, size_t blen);
u64    : bool equal_array_u64(u64* a, size_t alen, u64* b, size_t blen);
uint   : bool equal_array_uint(uint* a, size_t alen, uint* b, size_t blen);
```

## push {#two_push}

```C
push(coll, val)
```

Push a value onto the end of a collection. For Vec and String.

Members:

```C
String*            : void push_String(String *s, char c);
Vec(CStr)*         : void push_Vec_CStr(Vec_CStr *self, CStr value);
Vec(Rect2(float))* : void push_Vec_Rect2_float(Vec_Rect2_float *self, Rect2_float value);
Vec(Vec2(double))* : void push_Vec_Vec2_double(Vec_Vec2_double *self, Vec2_double value);
Vec(Vec2(float))*  : void push_Vec_Vec2_float(Vec_Vec2_float *self, Vec2_float value);
Vec(Vec2(int))*    : void push_Vec_Vec2_int(Vec_Vec2_int *self, Vec2_int value);
Vec(Vec3(int))*    : void push_Vec_Vec3_int(Vec_Vec3_int *self, Vec3_int value);
Vec(char)*         : void push_Vec_char(Vec_char *self, char value);
Vec(cstr)*         : void push_Vec_cstr(Vec_cstr *self, cstr value);
Vec(double)*       : void push_Vec_double(Vec_double *self, double value);
Vec(float)*        : void push_Vec_float(Vec_float *self, float value);
Vec(int)*          : void push_Vec_int(Vec_int *self, int value);
Vec(ucodepoint)*   : void push_Vec_ucodepoint(Vec_ucodepoint *self, ucodepoint value);
Vec(utf8char)*     : void push_Vec_utf8char(Vec_utf8char *self, utf8char value);
```

## pop {#two_pop}

```C
pop(coll)
```

Pop a value off the end of a collection. For Vec and String.

Members:

```C
Vec(CStr)*         : Option_CStr pop_Vec_CStr(Vec_CStr *self);
Vec(Rect2(float))* : Option_Rect2_float pop_Vec_Rect2_float(Vec_Rect2_float *self);
Vec(Vec2(double))* : Option_Vec2_double pop_Vec_Vec2_double(Vec_Vec2_double *self);
Vec(Vec2(float))*  : Option_Vec2_float pop_Vec_Vec2_float(Vec_Vec2_float *self);
Vec(Vec2(int))*    : Option_Vec2_int pop_Vec_Vec2_int(Vec_Vec2_int *self);
Vec(Vec3(int))*    : Option_Vec3_int pop_Vec_Vec3_int(Vec_Vec3_int *self);
Vec(char)*         : Option_char pop_Vec_char(Vec_char *self);
Vec(cstr)*         : Option_cstr pop_Vec_cstr(Vec_cstr *self);
Vec(double)*       : Option_double pop_Vec_double(Vec_double *self);
Vec(float)*        : Option_float pop_Vec_float(Vec_float *self);
Vec(int)*          : Option_int pop_Vec_int(Vec_int *self);
Vec(ucodepoint)*   : Option_ucodepoint pop_Vec_ucodepoint(Vec_ucodepoint *self);
Vec(utf8char)*     : Option_utf8char pop_Vec_utf8char(Vec_utf8char *self);
```

## append {#two_append}

```C
append(coll1, coll2)
```

Append the items from coll2 onto the end of coll1, leaving coll2
empty. For Vec and String.

Members:

```C
String*            : void append_String_String(String *a, String *b);
Vec(CStr)*         : void append_Vec_CStr(Vec_CStr *self, Vec_CStr *other);
Vec(Rect2(float))* : void append_Vec_Rect2_float(Vec_Rect2_float *self, Vec_Rect2_float *other);
Vec(Vec2(double))* : void append_Vec_Vec2_double(Vec_Vec2_double *self, Vec_Vec2_double *other);
Vec(Vec2(float))*  : void append_Vec_Vec2_float(Vec_Vec2_float *self, Vec_Vec2_float *other);
Vec(Vec2(int))*    : void append_Vec_Vec2_int(Vec_Vec2_int *self, Vec_Vec2_int *other);
Vec(Vec3(int))*    : void append_Vec_Vec3_int(Vec_Vec3_int *self, Vec_Vec3_int *other);
Vec(char)*         : void append_Vec_char(Vec_char *self, Vec_char *other);
Vec(cstr)*         : void append_Vec_cstr(Vec_cstr *self, Vec_cstr *other);
Vec(double)*       : void append_Vec_double(Vec_double *self, Vec_double *other);
Vec(float)*        : void append_Vec_float(Vec_float *self, Vec_float *other);
Vec(int)*          : void append_Vec_int(Vec_int *self, Vec_int *other);
Vec(ucodepoint)*   : void append_Vec_ucodepoint(Vec_ucodepoint *self, Vec_ucodepoint *other);
Vec(utf8char)*     : void append_Vec_utf8char(Vec_utf8char *self, Vec_utf8char *other);
```

## append_move {#two_append_move}

```C
append_move(coll1, coll2)
```

Append the items from coll2 onto the end of coll1, consuming
coll2. For Vec and String.

Members:

```C
String*            : void append_move_String_String(String *a, String b);
Vec(CStr)*         : void append_move_Vec_CStr(Vec_CStr *self, Vec_CStr other);
Vec(Rect2(float))* : void append_move_Vec_Rect2_float(Vec_Rect2_float *self, Vec_Rect2_float other);
Vec(Vec2(double))* : void append_move_Vec_Vec2_double(Vec_Vec2_double *self, Vec_Vec2_double other);
Vec(Vec2(float))*  : void append_move_Vec_Vec2_float(Vec_Vec2_float *self, Vec_Vec2_float other);
Vec(Vec2(int))*    : void append_move_Vec_Vec2_int(Vec_Vec2_int *self, Vec_Vec2_int other);
Vec(Vec3(int))*    : void append_move_Vec_Vec3_int(Vec_Vec3_int *self, Vec_Vec3_int other);
Vec(cstr)*         : void append_move_Vec_cstr(Vec_cstr *self, Vec_cstr other);
Vec(double)*       : void append_move_Vec_double(Vec_double *self, Vec_double other);
Vec(float)*        : void append_move_Vec_float(Vec_float *self, Vec_float other);
Vec(int)*          : void append_move_Vec_int(Vec_int *self, Vec_int other);
Vec(ucodepoint)*   : void append_move_Vec_ucodepoint(Vec_ucodepoint *self, Vec_ucodepoint other);
```

## len {#two_len}

```C
len(coll)
```

Give the length of a given collection. It always reports the
number of identically-sized storage locations, which means that
for String, it reports the number of bytes (C char), not the
number of unicode codepoints.

Members:

```C
String*                     : size_t len_String(const String *s);
Vec(CStr)*                  : size_t len_Vec_CStr(const Vec_CStr *self);
Vec(Rect2(float))*          : size_t len_Vec_Rect2_float(const Vec_Rect2_float *self);
Vec(Vec2(double))*          : size_t len_Vec_Vec2_double(const Vec_Vec2_double *self);
Vec(Vec2(float))*           : size_t len_Vec_Vec2_float(const Vec_Vec2_float *self);
Vec(Vec2(int))*             : size_t len_Vec_Vec2_int(const Vec_Vec2_int *self);
Vec(Vec3(int))*             : size_t len_Vec_Vec3_int(const Vec_Vec3_int *self);
Vec(char)*                  : size_t len_Vec_char(const Vec_char *self);
Vec(cstr)*                  : size_t len_Vec_cstr(const Vec_cstr *self);
Vec(double)*                : size_t len_Vec_double(const Vec_double *self);
Vec(float)*                 : size_t len_Vec_float(const Vec_float *self);
Vec(int)*                   : size_t len_Vec_int(const Vec_int *self);
Vec(ucodepoint)*            : size_t len_Vec_ucodepoint(const Vec_ucodepoint *self);
Vec(utf8char)*              : size_t len_Vec_utf8char(const Vec_utf8char *self);
const String*               : size_t len_String(const String *s);
const Vec(CStr)*            : size_t len_Vec_CStr(const Vec_CStr *self);
const Vec(char)*            : size_t len_Vec_char(const Vec_char *self);
const Vec(cstr)*            : size_t len_Vec_cstr(const Vec_cstr *self);
const Vec(double)*          : size_t len_Vec_double(const Vec_double *self);
const Vec(float)*           : size_t len_Vec_float(const Vec_float *self);
const Vec(int)*             : size_t len_Vec_int(const Vec_int *self);
const Vec(ucodepoint)*      : size_t len_Vec_ucodepoint(const Vec_ucodepoint *self);
const Vec(utf8char)*        : size_t len_Vec_utf8char(const Vec_utf8char *self);
const mutslice(CStr)*       : size_t len_mutslice_CStr(const mutslice_CStr *self);
const mutslice(char)*       : size_t len_mutslice_char(const mutslice_char *self);
const mutslice(cstr)*       : size_t len_mutslice_cstr(const mutslice_cstr *self);
const mutslice(int)*        : size_t len_mutslice_int(const mutslice_int *self);
const mutslice(ucodepoint)* : size_t len_mutslice_ucodepoint(const mutslice_ucodepoint *self);
const mutslice(utf8char)*   : size_t len_mutslice_utf8char(const mutslice_utf8char *self);
const slice(CStr)*          : size_t len_slice_CStr(const slice_CStr *self);
const slice(char)*          : size_t len_slice_char(const slice_char *self);
const slice(cstr)*          : size_t len_slice_cstr(const slice_cstr *self);
const slice(int)*           : size_t len_slice_int(const slice_int *self);
const slice(ucodepoint)*    : size_t len_slice_ucodepoint(const slice_ucodepoint *self);
const slice(utf8char)*      : size_t len_slice_utf8char(const slice_utf8char *self);
mutslice(CStr)*             : size_t len_mutslice_CStr(const mutslice_CStr *self);
mutslice(char)*             : size_t len_mutslice_char(const mutslice_char *self);
mutslice(cstr)*             : size_t len_mutslice_cstr(const mutslice_cstr *self);
mutslice(int)*              : size_t len_mutslice_int(const mutslice_int *self);
mutslice(ucodepoint)*       : size_t len_mutslice_ucodepoint(const mutslice_ucodepoint *self);
mutslice(utf8char)*         : size_t len_mutslice_utf8char(const mutslice_utf8char *self);
slice(CStr)*                : size_t len_slice_CStr(const slice_CStr *self);
slice(char)*                : size_t len_slice_char(const slice_char *self);
slice(cstr)*                : size_t len_slice_cstr(const slice_cstr *self);
slice(int)*                 : size_t len_slice_int(const slice_int *self);
slice(ucodepoint)*          : size_t len_slice_ucodepoint(const slice_ucodepoint *self);
slice(utf8char)*            : size_t len_slice_utf8char(const slice_utf8char *self);
```

## cstr {#two_cstr}

```C
cstr(v)
```

Give a cstr to the given character collection. Note that this may
return an error if the collection contains `'\0'` bytes.

Members:

```C
CStr*     : cstr cstr_CStr(CStr *s);
String*   : Option(cstr) cstr_String(String *s);
utf8char* : cstr cstr_utf8char(const utf8char *c);
```

## fprintln {#two_fprintln}

```C
fprintln(out, v)
```

Like println but printing to `out`.

(Currently only defined for types for which `unwrap` is defined,
to be used for error messaging. Todo: define `println` in terms of
`fprintln` and thus share implementations.)

Members:

```C
CStrError*     : int fprintln_CStrError(FILE *out, const CStrError *e);
DecodingError* : int fprintln_DecodingError(FILE* out, const DecodingError* e);
ParseError*    : int fprintln_ParseError(FILE* out, const ParseError *e);
String*        : int fprintln_String(FILE *out, const String *s);
SystemError*   : int fprintln_SystemError(FILE* out, const SystemError *e);
UnicodeError*  : int fprintln_UnicodeError(FILE* out, const UnicodeError* e);
VecError*      : int fprintln_VecError(FILE *out, const VecError *e);
```

## get_utf8char {#two_get_utfQeightEchar}

```C
get_utf8char(s, idx)
```

Get a `utf8char` from a collection. DEPRECATED, use get_ucodepoint
instead.

Members:

```C
String* : Option(utf8char) get_utf8char_String(const String *s, size_t idx);
```

## get_ucodepoint {#two_get_ucodepoint}

```C
get_ucodepoint(s, idx)
```

Get a `ucodepoint` from a collection.

Members:

```C
String* : Option(ucodepoint) get_ucodepoint_String(const String *s, size_t idx);
```

## clear {#two_clear}

```C
clear(s)
```

Clear a collection or similar thing (make it empty).

Members:

```C
SDL_Renderer*      : clear_SDL_Renderer /* evil? */;
String*            : void clear_String(String *s);
Vec(CStr)*         : void clear_Vec_CStr(Vec_CStr *self);
Vec(Rect2(float))* : void clear_Vec_Rect2_float(Vec_Rect2_float *self);
Vec(Vec2(double))* : void clear_Vec_Vec2_double(Vec_Vec2_double *self);
Vec(Vec2(float))*  : void clear_Vec_Vec2_float(Vec_Vec2_float *self);
Vec(Vec2(int))*    : void clear_Vec_Vec2_int(Vec_Vec2_int *self);
Vec(Vec3(int))*    : void clear_Vec_Vec3_int(Vec_Vec3_int *self);
Vec(char)*         : void clear_Vec_char(Vec_char *self);
Vec(cstr)*         : void clear_Vec_cstr(Vec_cstr *self);
Vec(double)*       : void clear_Vec_double(Vec_double *self);
Vec(float)*        : void clear_Vec_float(Vec_float *self);
Vec(int)*          : void clear_Vec_int(Vec_int *self);
Vec(ucodepoint)*   : void clear_Vec_ucodepoint(Vec_ucodepoint *self);
Vec(utf8char)*     : void clear_Vec_utf8char(Vec_utf8char *self);
```

## read_until {#two_read_until}

```C
read_until(in, delimiter, buf, strip_delimiter, max_len)
```

Read items into buf until the delimiter or EOF is reached.

Members:

```C
\
             , Vec(ucodepoint)* : Result(size_t, UnicodeError) read_until_Vec_ucodepoint
    (CFile *in,
     ucodepoint delimiter,
     Vec(ucodepoint) *buf,
     bool strip_delimiter,
     size_t max_len);
```

## read_line {#two_read_line}

```C
read_line(in, buf, strip_delimiter, max_len)
```

Read items into buf until a newline character (`'\n'`) or EOF is
reached.

Members:

```C
\
             , Vec(ucodepoint)* : Result(size_t, UnicodeError) read_line_Vec_ucodepoint
    (CFile *in,
     Vec(ucodepoint) *buf,
     bool strip_delimiter,
     size_t max_len);
```

## get_ucodepoint_unlocked {#two_get_ucodepoint_unlocked}

```C
get_ucodepoint_unlocked(in)
```

Read an ucodepoint from `in`.

Members:

```C
CFile*               : Result(Option(ucodepoint), UnicodeError) get_ucodepoint_unlocked_CFile(CFile *in);
SliceIterator(char)* : Result(Option(ucodepoint), UnicodeError) get_ucodepoint_unlocked_SliceIterator_char(
    SliceIterator(char) *in);
```

## new_String_from {#two_new_String_from}

```C
new_String_from(v)
```

Create a String from various types. (Ideally the same as
`new_from(String, v)`, but that one has fewer entries.)

Members:

```C
CStr          : String new_String_from_CStr(CStr s);
DecodingError : String new_String_from_DecodingError(DecodingError e);
ParseError    : String new_String_from_ParseError(ParseError e);
String        : String new_String_from_String(String s);
SystemError   : String new_String_from_SystemError(SystemError e);
UnicodeError  : String new_String_from_UnicodeError(UnicodeError e);
char*         : String new_String_from_move_cstr(cstr s);
const cstr*   : String new_String_from_cstr(const cstr *s);
cstr          : String new_String_from_move_cstr(cstr s);
cstr*         : String new_String_from_cstr(const cstr *s);
int           : String new_String_from_move_int(int v);
size_t        : String new_String_from_move_size_t(size_t v);
slice(char)   : String new_String_from_slice_char(slice(char) s);
```

## at {#two_at}

```C
at(v, idx)
```

Get a read-only reference to the element at position `i`. Aborts if `i` is
behind the end of the vectorlike. If you are not sure if
`i` is valid, use `get` instead.

Members:

```C
Vec(CStr)*              : const CStr* at_Vec_CStr(const Vec_CStr *self, size_t idx);
Vec(Rect2(float))*      : const Rect2_float* at_Vec_Rect2_float(const Vec_Rect2_float *self, size_t idx);
Vec(Vec2(double))*      : const Vec2_double* at_Vec_Vec2_double(const Vec_Vec2_double *self, size_t idx);
Vec(Vec2(float))*       : const Vec2_float* at_Vec_Vec2_float(const Vec_Vec2_float *self, size_t idx);
Vec(Vec2(int))*         : const Vec2_int* at_Vec_Vec2_int(const Vec_Vec2_int *self, size_t idx);
Vec(Vec3(int))*         : const Vec3_int* at_Vec_Vec3_int(const Vec_Vec3_int *self, size_t idx);
Vec(char)*              : const char* at_Vec_char(const Vec_char *self, size_t idx);
Vec(cstr)*              : const cstr* at_Vec_cstr(const Vec_cstr *self, size_t idx);
Vec(double)*            : const double* at_Vec_double(const Vec_double *self, size_t idx);
Vec(float)*             : const float* at_Vec_float(const Vec_float *self, size_t idx);
Vec(int)*               : const int* at_Vec_int(const Vec_int *self, size_t idx);
Vec(ucodepoint)*        : const ucodepoint* at_Vec_ucodepoint(const Vec_ucodepoint *self, size_t idx);
const Vec(char)*        : const char* at_Vec_char(const Vec_char *self, size_t idx);
const Vec(double)*      : const double* at_Vec_double(const Vec_double *self, size_t idx);
const Vec(float)*       : const float* at_Vec_float(const Vec_float *self, size_t idx);
const Vec(int)*         : const int* at_Vec_int(const Vec_int *self, size_t idx);
const Vec(ucodepoint)*  : const ucodepoint* at_Vec_ucodepoint(const Vec_ucodepoint *self, size_t idx);
const mutslice(char)*   : const char* at_mutslice_char(const mutslice_char *self, size_t idx);
const mutslice(int)*    : const int* at_mutslice_int(const mutslice_int *self, size_t idx);
const slice(char)*      : const char* at_slice_char(const slice_char *self, size_t idx);
const slice(int)*       : const int* at_slice_int(const slice_int *self, size_t idx);
mutslice(CStr)*         : const CStr* at_mutslice_CStr(const mutslice_CStr *self, size_t idx);
mutslice(Rect2(float))* : const Rect2_float* at_mutslice_Rect2_float(const mutslice_Rect2_float *self, size_t idx);
mutslice(Vec2(double))* : const Vec2_double* at_mutslice_Vec2_double(const mutslice_Vec2_double *self, size_t idx);
mutslice(Vec2(float))*  : const Vec2_float* at_mutslice_Vec2_float(const mutslice_Vec2_float *self, size_t idx);
mutslice(Vec2(int))*    : const Vec2_int* at_mutslice_Vec2_int(const mutslice_Vec2_int *self, size_t idx);
mutslice(char)*         : const char* at_mutslice_char(const mutslice_char *self, size_t idx);
mutslice(cstr)*         : const cstr* at_mutslice_cstr(const mutslice_cstr *self, size_t idx);
mutslice(double)*       : const double* at_mutslice_double(const mutslice_double *self, size_t idx);
mutslice(float)*        : const float* at_mutslice_float(const mutslice_float *self, size_t idx);
mutslice(int)*          : const int* at_mutslice_int(const mutslice_int *self, size_t idx);
mutslice(ucodepoint)*   : const ucodepoint* at_mutslice_ucodepoint(const mutslice_ucodepoint *self, size_t idx);
slice(CStr)*            : const CStr* at_slice_CStr(const slice_CStr *self, size_t idx);
slice(Rect2(float))*    : const Rect2_float* at_slice_Rect2_float(const slice_Rect2_float *self, size_t idx);
slice(Vec2(double))*    : const Vec2_double* at_slice_Vec2_double(const slice_Vec2_double *self, size_t idx);
slice(Vec2(float))*     : const Vec2_float* at_slice_Vec2_float(const slice_Vec2_float *self, size_t idx);
slice(Vec2(int))*       : const Vec2_int* at_slice_Vec2_int(const slice_Vec2_int *self, size_t idx);
slice(char)*            : const char* at_slice_char(const slice_char *self, size_t idx);
slice(cstr)*            : const cstr* at_slice_cstr(const slice_cstr *self, size_t idx);
slice(double)*          : const double* at_slice_double(const slice_double *self, size_t idx);
slice(float)*           : const float* at_slice_float(const slice_float *self, size_t idx);
slice(int)*             : const int* at_slice_int(const slice_int *self, size_t idx);
slice(ucodepoint)*      : const ucodepoint* at_slice_ucodepoint(const slice_ucodepoint *self, size_t idx);
```

## get {#two_get}

```C
get(v, idx)
```

Get a read-only reference to the element at position `i`. Returns none if
`i` is behind the end of the vectorlike. If you are sure that `i` is valid,
you can use `at` instead.

Members:

```C
Vec(CStr)*              : Option_ref_CStr get_Vec_CStr(const Vec_CStr *self, size_t idx);
Vec(Rect2(float))*      : Option_ref_Rect2_float get_Vec_Rect2_float(const Vec_Rect2_float *self, size_t idx);
Vec(Vec2(double))*      : Option_ref_Vec2_double get_Vec_Vec2_double(const Vec_Vec2_double *self, size_t idx);
Vec(Vec2(float))*       : Option_ref_Vec2_float get_Vec_Vec2_float(const Vec_Vec2_float *self, size_t idx);
Vec(Vec2(int))*         : Option_ref_Vec2_int get_Vec_Vec2_int(const Vec_Vec2_int *self, size_t idx);
Vec(Vec3(int))*         : Option_ref_Vec3_int get_Vec_Vec3_int(const Vec_Vec3_int *self, size_t idx);
Vec(char)*              : Option_ref_char get_Vec_char(const Vec_char *self, size_t idx);
Vec(cstr)*              : Option_ref_cstr get_Vec_cstr(const Vec_cstr *self, size_t idx);
Vec(double)*            : Option_ref_double get_Vec_double(const Vec_double *self, size_t idx);
Vec(float)*             : Option_ref_float get_Vec_float(const Vec_float *self, size_t idx);
Vec(int)*               : Option_ref_int get_Vec_int(const Vec_int *self, size_t idx);
Vec(ucodepoint)*        : Option_ref_ucodepoint get_Vec_ucodepoint(const Vec_ucodepoint *self, size_t idx);
const Vec(char)*        : Option_ref_char get_Vec_char(const Vec_char *self, size_t idx);
const Vec(double)*      : Option_ref_double get_Vec_double(const Vec_double *self, size_t idx);
const Vec(float)*       : Option_ref_float get_Vec_float(const Vec_float *self, size_t idx);
const Vec(int)*         : Option_ref_int get_Vec_int(const Vec_int *self, size_t idx);
const Vec(ucodepoint)*  : Option_ref_ucodepoint get_Vec_ucodepoint(const Vec_ucodepoint *self, size_t idx);
const mutslice(char)*   : Option_ref_char get_mutslice_char(const mutslice_char *self, size_t idx);
const mutslice(int)*    : Option_ref_int get_mutslice_int(const mutslice_int *self, size_t idx);
const slice(char)*      : Option_ref_char get_slice_char(const slice_char *self, size_t idx);
const slice(int)*       : Option_ref_int get_slice_int(const slice_int *self, size_t idx);
mutslice(CStr)*         : Option_ref_CStr get_mutslice_CStr(const mutslice_CStr *self, size_t idx);
mutslice(Rect2(float))* : Option_ref_Rect2_float get_mutslice_Rect2_float(const mutslice_Rect2_float *self, size_t idx);
mutslice(Vec2(double))* : Option_ref_Vec2_double get_mutslice_Vec2_double(const mutslice_Vec2_double *self, size_t idx);
mutslice(Vec2(float))*  : Option_ref_Vec2_float get_mutslice_Vec2_float(const mutslice_Vec2_float *self, size_t idx);
mutslice(Vec2(int))*    : Option_ref_Vec2_int get_mutslice_Vec2_int(const mutslice_Vec2_int *self, size_t idx);
mutslice(char)*         : Option_ref_char get_mutslice_char(const mutslice_char *self, size_t idx);
mutslice(cstr)*         : Option_ref_cstr get_mutslice_cstr(const mutslice_cstr *self, size_t idx);
mutslice(double)*       : Option_ref_double get_mutslice_double(const mutslice_double *self, size_t idx);
mutslice(float)*        : Option_ref_float get_mutslice_float(const mutslice_float *self, size_t idx);
mutslice(int)*          : Option_ref_int get_mutslice_int(const mutslice_int *self, size_t idx);
mutslice(ucodepoint)*   : Option_ref_ucodepoint get_mutslice_ucodepoint(const mutslice_ucodepoint *self, size_t idx);
slice(CStr)*            : Option_ref_CStr get_slice_CStr(const slice_CStr *self, size_t idx);
slice(Rect2(float))*    : Option_ref_Rect2_float get_slice_Rect2_float(const slice_Rect2_float *self, size_t idx);
slice(Vec2(double))*    : Option_ref_Vec2_double get_slice_Vec2_double(const slice_Vec2_double *self, size_t idx);
slice(Vec2(float))*     : Option_ref_Vec2_float get_slice_Vec2_float(const slice_Vec2_float *self, size_t idx);
slice(Vec2(int))*       : Option_ref_Vec2_int get_slice_Vec2_int(const slice_Vec2_int *self, size_t idx);
slice(char)*            : Option_ref_char get_slice_char(const slice_char *self, size_t idx);
slice(cstr)*            : Option_ref_cstr get_slice_cstr(const slice_cstr *self, size_t idx);
slice(double)*          : Option_ref_double get_slice_double(const slice_double *self, size_t idx);
slice(float)*           : Option_ref_float get_slice_float(const slice_float *self, size_t idx);
slice(int)*             : Option_ref_int get_slice_int(const slice_int *self, size_t idx);
slice(ucodepoint)*      : Option_ref_ucodepoint get_slice_ucodepoint(const slice_ucodepoint *self, size_t idx);
```

## set {#two_set}

```C
set(v, idx, val)
```

Move the given `val` into the slot with the given `idx`,
replacing the value that was there previously. Aborts if the index
isn't smaller than the current `len` of the vector.

Members:

```C
Vec(Vec2(double))*    : void set_Vec_Vec2_double(Vec_Vec2_double *self, size_t index, Vec2_double value);
Vec(Vec2(float))*     : void set_Vec_Vec2_float(Vec_Vec2_float *self, size_t index, Vec2_float value);
Vec(Vec2(int))*       : void set_Vec_Vec2_int(Vec_Vec2_int *self, size_t index, Vec2_int value);
Vec(Vec3(int))*       : void set_Vec_Vec3_int(Vec_Vec3_int *self, size_t index, Vec3_int value);
Vec(char)*            : void set_Vec_char(Vec_char *self, size_t index, char value);
Vec(double)*          : void set_Vec_double(Vec_double *self, size_t index, double value);
Vec(float)*           : void set_Vec_float(Vec_float *self, size_t index, float value);
Vec(int)*             : void set_Vec_int(Vec_int *self, size_t index, int value);
const Vec(char)*      : void set_Vec_char(Vec_char *self, size_t index, char value);
const Vec(double)*    : void set_Vec_double(Vec_double *self, size_t index, double value);
const Vec(float)*     : void set_Vec_float(Vec_float *self, size_t index, float value);
const Vec(int)*       : void set_Vec_int(Vec_int *self, size_t index, int value);
const mutslice(char)* : void set_mutslice_char(mutslice_char *self, size_t index, char value);
const mutslice(int)*  : void set_mutslice_int(mutslice_int *self, size_t index, int value);
mutslice(char)*       : void set_mutslice_char(mutslice_char *self, size_t index, char value);
mutslice(int)*        : void set_mutslice_int(mutslice_int *self, size_t index, int value);
```

## slice_of {#two_slice_of}

```C
slice_of(v, range)
```

Create a slice of various collection types. A slice is borrowing a
range of items from the original collection. Careful, these
"always succeed": if the range is not applicable, they abort.

Members:

```C
Vec(Vec2(double))*    : slice_Vec2_double slice_of_Vec_Vec2_double(const Vec_Vec2_double *self, Range range);
Vec(Vec2(float))*     : slice_Vec2_float slice_of_Vec_Vec2_float(const Vec_Vec2_float *self, Range range);
Vec(Vec2(int))*       : slice_Vec2_int slice_of_Vec_Vec2_int(const Vec_Vec2_int *self, Range range);
Vec(Vec3(int))*       : slice_Vec3_int slice_of_Vec_Vec3_int(const Vec_Vec3_int *self, Range range);
Vec(char)*            : slice_char slice_of_Vec_char(const Vec_char *self, Range range);
Vec(double)*          : slice_double slice_of_Vec_double(const Vec_double *self, Range range);
Vec(float)*           : slice_float slice_of_Vec_float(const Vec_float *self, Range range);
Vec(int)*             : slice_int slice_of_Vec_int(const Vec_int *self, Range range);
const Vec(char)*      : slice_char slice_of_Vec_char(const Vec_char *self, Range range);
const Vec(double)*    : slice_double slice_of_Vec_double(const Vec_double *self, Range range);
const Vec(float)*     : slice_float slice_of_Vec_float(const Vec_float *self, Range range);
const Vec(int)*       : slice_int slice_of_Vec_int(const Vec_int *self, Range range);
const mutslice(char)* : slice_char slice_of_mutslice_char(const mutslice_char *self, Range range);
const mutslice(int)*  : slice_int slice_of_mutslice_int(const mutslice_int *self, Range range);
const slice(char)*    : slice_char slice_of_slice_char(const slice_char *self, Range range);
const slice(int)*     : slice_int slice_of_slice_int(const slice_int *self, Range range);
mutslice(char)*       : slice_char slice_of_mutslice_char(const mutslice_char *self, Range range);
mutslice(int)*        : slice_int slice_of_mutslice_int(const mutslice_int *self, Range range);
slice(char)*          : slice_char slice_of_slice_char(const slice_char *self, Range range);
slice(int)*           : slice_int slice_of_slice_int(const slice_int *self, Range range);
```

## mutslice_of {#two_mutslice_of}

```C
mutslice_of(v, range)
```

Create a mutable slice of various collection types. A slice is borrowing a
range of items from the original collection. Careful, these
"always succeed": if the range is not applicable, they abort.

Members:

```C
Vec(Vec2(double))*    : mutslice_Vec2_double mutslice_of_Vec_Vec2_double(Vec_Vec2_double *self, Range range);
Vec(Vec2(float))*     : mutslice_Vec2_float mutslice_of_Vec_Vec2_float(Vec_Vec2_float *self, Range range);
Vec(Vec2(int))*       : mutslice_Vec2_int mutslice_of_Vec_Vec2_int(Vec_Vec2_int *self, Range range);
Vec(Vec3(int))*       : mutslice_Vec3_int mutslice_of_Vec_Vec3_int(Vec_Vec3_int *self, Range range);
Vec(char)*            : mutslice_char mutslice_of_Vec_char(Vec_char *self, Range range);
Vec(double)*          : mutslice_double mutslice_of_Vec_double(Vec_double *self, Range range);
Vec(float)*           : mutslice_float mutslice_of_Vec_float(Vec_float *self, Range range);
Vec(int)*             : mutslice_int mutslice_of_Vec_int(Vec_int *self, Range range);
const Vec(char)*      : mutslice_char mutslice_of_Vec_char(Vec_char *self, Range range);
const Vec(double)*    : mutslice_double mutslice_of_Vec_double(Vec_double *self, Range range);
const Vec(float)*     : mutslice_float mutslice_of_Vec_float(Vec_float *self, Range range);
const Vec(int)*       : mutslice_int mutslice_of_Vec_int(Vec_int *self, Range range);
const mutslice(char)* : mutslice_char mutslice_of_mutslice_char(mutslice_char *self, Range range);
const mutslice(int)*  : mutslice_int mutslice_of_mutslice_int(mutslice_int *self, Range range);
mutslice(char)*       : mutslice_char mutslice_of_mutslice_char(mutslice_char *self, Range range);
mutslice(int)*        : mutslice_int mutslice_of_mutslice_int(mutslice_int *self, Range range);
```

## get_slice_of {#two_get_slice_of}

```C
get_slice_of(v, range)
```

Create a slice of various collection types. A slice is borrowing a
range of items from the original collection. These return None if
the given range is not applicable.

Members:

```C
String*       : Option(strslice) get_slice_of_String(const String *s, Range range);
const String* : Option(strslice) get_slice_of_String(const String *s, Range range);
```

## rect2 {#two_rectQtwoE}

```C
rect2(start, extent)
```

Create a Rect2 (see [cj50/gen/Rect2.h](cj50/gen/Rect2.h.md)).

Members:

```C
Vec2(double) : Rect2_double rect2_double(Vec2_double start, Vec2_double extent);
Vec2(float)  : Rect2_float rect2_float(Vec2_float start, Vec2_float extent);
Vec2(int)    : Rect2_int rect2_int(Vec2_int start, Vec2_int extent);
```

# Macros

## DBG {#three_DBG}

```C
DBG(expr)
```

"DeBuG": print the expression `expr` and the value it evaluated to, for
debugging purposes (calls `print_debug` on the value). Returns the value,
although note that this is only valid if the value is of a Copy type
(including references). See `DBGV` for a variant that handles non-Copy types
that way.

## DBGV {#three_DBGV}

```C
DBGV(expr)
```

"DeBuG (non-reference) value": print the expression `expr` and the value it
evaluated to, for debugging purposes (calls `print_debug` on the reference
to the value). Returns the value; unlike `DBG`, this does not move the
value, hence the return value of `DBGV` *must* be used if it is not a Copy
type (`DBGV` never drops it). OTOH, `DBGV` can't be used on references,
because that would lead to a double reference being passed to `print_debug`;
use `DBG` for those.

Is expr evaluating to a reference? -> use `DBG`. Otherwise, do you want to
pick up the return value? -> use `DBGV`. Otherwise use `DBG`.

## DBGA {#three_DBGA}

```C
DBGA(expr, len)
```

`DBG` `A`rray: print the expression `expr` and the array value
it evaluated to, for debugging purposes (calls
`print_debug_array`). `len` must give the length of the array.

## String {#three_String}

```C
String(val)
```

Create a `String` easily; this is just an alias for
`new_String_from`.

## MAIN {#three_MAIN}

```C
MAIN(mainfunction)
```

`MAIN` takes the name of the function to run when the program
starts. `mainfunction` receives a `slice` of `cstr` values which
are holding the program name in position 0 (usually, but not
actually guaranteed) and then the program arguments, and must
return a Result. If it returns an Err, the program will exit with
exit code 1, if it returns Ok, with exit code 0. (The Ok value
itself is currently being ignored.)

`MAIN` defines the function `main` (hence `mainfunction` cannot be
called `main`).

```C
Result(Unit, UnicodeError) run(slice(cstr) argv) {
    ...
}

MAIN(run);
```

<hr>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
