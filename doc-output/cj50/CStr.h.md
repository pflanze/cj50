<!-- THIS FILE WAS AUTO-GENERATED by gendoc. DO NOT EDIT! -->

# Types

## CStr {#zero_CStr}

```C
typedef struct CStr {
    char* cstr;
} CStr
```

`CStr` is a mutable owned type that represents a "C string". It
embeds an array of `char`, that represents the text and a '\0'
character after it to signal the end of the text. There is no
length information, the length has to be determined by walking the
array until encountering the '\0' character (`strlen` will do
that). In addition to `cstr` it guarantees that there are no '\0'
characters contained in the text (functions generating `CStr` must
verify for that to be true).

## CStrError {#zero_CStrError}

```C
typedef struct CStrError {
    uint8_t code;
} CStrError
```

A type indicating an error handling C strings. The instances are:

    CSE_missing_terminator
    CSE_contains_nul
    CSE_size_0

# Type aliases

## cstr {#zero.one_cstr}

```C
typedef const char* cstr
```

`cstr` is a non-mutable borrowed type that represents a "C
string". It is an array of `char`, that represents the text and a
'\0' character after it to signal the end of the text. There is no
length information, the length has to be determined by walking the
array until encountering the '\0' character (`strlen` will do
that).

# Normal functions

## equal_cstr {#one_equal_cstr}

```C
bool equal_cstr(const cstr *a, const cstr *b)
```

Check equivalence. (Standard borrowing API, even though cstr is
already a reference type.)

## equal_move_cstr {#one_equal_move_cstr}

```C
bool equal_move_cstr(cstr a, cstr b)
```

Check equivalence, "consuming" the references, although consuming
references is a NOOP (those are Copy, and the referenced value is
not dropped). Offered to satisfy the expectation that one can
compare reference types without using `&`.

## print_cstr {#one_print_cstr}

```C
int print_cstr(const cstr *s)
```

Print for program user.

## print_move_cstr {#one_print_move_cstr}

```C
int print_move_cstr(cstr s)
```

Same as `print_cstr`, but move (rather, copy) the reference. Like
print_cstr, still does not consume `s` since it's a borrowed type
anyway.

## print_debug_cstr {#one_print_debug_cstr}

```C
int print_debug_cstr(const cstr *s)
```

Print in C code syntax.

## print_debug_move_cstr {#one_print_debug_move_cstr}

```C
int print_debug_move_cstr(cstr s)
```

Same as `print_debug_move_cstr`, again move/copy but it's a
borrowed type anyway.

## drop_CStr {#one_drop_CStr}

```C
void drop_CStr(CStr s)
```

Remove from existence.

## equal_CStr {#one_equal_CStr}

```C
bool equal_CStr(const CStr *a, const CStr *b)
```

Check equivalence.

## print_debug_CStr {#one_print_debug_CStr}

```C
int print_debug_CStr(const CStr *s)
```

Print in C code syntax.

## print_debug_move_CStr {#one_print_debug_move_CStr}

```C
int print_debug_move_CStr(CStr s)
```

Same as `print_debug_CStr` but consuming `s`.

## equal_CStrError {#one_equal_CStrError}

```C
bool equal_CStrError(const CStrError *a, const CStrError *b)
```

Check equivalence.

## print_debug_CStrError {#one_print_debug_CStrError}

```C
int print_debug_CStrError(const CStrError *e)
```

Print in C code syntax.

## fprintln_CStrError {#one_fprintln_CStrError}

```C
int fprintln_CStrError(FILE *out, const CStrError *e)
```

Print for program user.

## cStr_from_cstr {#one_cStr_from_cstr}

```C
Result(CStr, CStrError) cStr_from_cstr(char *s, size_t siz)
```

Consume `s`, verify that it ends with a '\0' but does not contain
any '\0' elsewhere. `siz` is the length including the '\0'
terminator.

## new_CStr {#one_new_CStr}

```C
CStr new_CStr(size_t len)
```

Allocate space for a C string of capacity `len`. Aborts when there
is not enough memory. All slots are set to '\0' (the string starts
out as the empty string).

NOTE: This means that the contained cstr is *not* a '\0'-less
string as required by `cStr_from_cstr` with regards to `len`. It
is shortened to the first '\0' encountered. Mutating the contained
cstr is *unsafe* (nothing except your being careful is preventing
you from writing behind the end of the contained cstr (buffer
overflow), and nothing is preventing you from filling it with
non-'\0' characters till the end meaning it loses its terminator).

## print_CStr {#one_print_CStr}

```C
int print_CStr(const CStr *s)
```

Print a CStr (without any escaping) to stdout.

## print_move_CStr {#one_print_move_CStr}

```C
int print_move_CStr(CStr s)
```

Like print_CStr but consuming the argument.

## cstr_CStr {#one_cstr_CStr}

```C
cstr cstr_CStr(CStr *s)
```

Give a read-only borrow to the contained cstr.

## deref_CStr {#one_deref_CStr}

```C
cstr deref_CStr(const CStr *s)
```

"Dereference" the `CStr` wrapper, meaning, get the wrapped value
out, a `cstr`.

# Macros

## CStr_from_cstr_unsafe {#three_CStr_from_cstr_unsafe}

```C
CStr_from_cstr_unsafe(s)
```

Generate a `CStr` from a `cstr`. `cstr` must end with a '\0' and
not contain any '\0' in other places; this is not checked, hence
unsafe.

<hr>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
